#encoding: utf-8
=begin rdoc
Tests for minitest-filecontent
=end
$:.unshift('../lib')
require 'minitest/filecontent'

#Some content to be tested.
DUMMYTEXT = <<dummytext
Some text to be tested.
More text.
dummytext

DUMMYTEXT_utf = <<dummytext
Some text to be tested.
More text.

Umlauts: öäü
dummytext

#
#This two directories will be created.
#
$expected = File.dirname(__FILE__) + '/tmp_expected'
$folder_for_failure  = File.dirname(__FILE__) + '/tmp_failure'



#
class Test_equal_filecontent_filename < MiniTest::Test
  def test_normal
    assert_equal('x', build_filename('x'))
  end
  def test_c
    assert_equal(self.class.to_s, build_filename('<c>'))
  end
  def test_m
    assert_equal(__method__.to_s, build_filename('<m>',0))
    assert_equal('test_m', build_filename('<m>',0))
  end
  def test_cm
    assert_equal("#{self.class}-#{__method__}", build_filename('<cm>',0))
  end

  #test if the filename is taken from deeper.
  def my_cascaded_test(methodname, level=0)
    assert_equal(methodname.to_s, build_filename('<m>',level), 'The filename is not generated by the calling process')
  end
  def my_cascaded_test2(methodname, level)
    my_cascaded_test(methodname, level)
  end
  def test_m_cascaded
    my_cascaded_test('my_cascaded_test')
    my_cascaded_test(__method__,1)
    my_cascaded_test2(__method__,2)
  end
end #Test_equal_filecontent_filename

=begin
This is a test in the test (we test with MiniTest the behavour of minitest.

Example:

    msg = assert_raises( Minitest::Assertion ){
      assert_equal_filecontent( "#{$expected}/test_build.txt", DUMMYTEXT )
    }
    
assert_raises checks, if the check assert_equal_filecontent throws an test-exception.
This exception (msg) can be analysed.
=end
class Test_equal_filecontent < MiniTest::Test
  
  #~ Minitest::Assertion = Test::Unit::Minitest::Assertion
  
  #Build reference data
  def self.before_tests()
    FileUtils.makedirs($expected)
    File.open("#{$expected}/test.txt", 'w'){|f| f << DUMMYTEXT }
    File.open("#{$expected}/test_utf.txt", 'w:utf-8'){|f| f << DUMMYTEXT_utf }
    File.open("#{$expected}/test_build.txt", 'w'){|f| f << DUMMYTEXT*2 }
  end
  before_tests()  #init
  def self.after_tests
    ###FIXME does not work
        
    FileUtils.rmtree($expected)
    FileUtils.rmtree($folder_for_failure)
    FileUtils.rmtree(FOLDER_FOR_FAILURE)
  end
  
  def test_ok()
    #~ #Make test
    assert_equal_filecontent( "#{$expected}/test.txt", DUMMYTEXT )
  end
  
  def test_utf()
    assert_equal_filecontent( "#{$expected}/test_utf.txt", DUMMYTEXT_utf )
  end

#Check error
  def test_no_reference_file()
    self.folder_for_failure = false  #inactivate error/reference file creation.
    #Check exception and get the message
    msg = assert_raises( Minitest::Assertion ){
      assert_equal_filecontent( "#{$expected}/not_available.txt", DUMMYTEXT )
    }    
    assert_instance_of(Minitest::Assertion, msg)
    assert_equal( "Reference file <#{$expected}/not_available.txt> is missing", msg.to_s)
  end
  
  #Check, if "Failure" is created in default path
  def test_build_reference_file_default_path()
    
    #First check. There is a difference, in failure we get the correct result
    msg = assert_raises( Minitest::Assertion ){
      assert_equal_filecontent( "#{$expected}/test_build.txt", DUMMYTEXT )
    }
    assert_match( %r{Result differs to file content #{$expected}/test_build.txt\n\t-> Build <#{FOLDER_FOR_FAILURE}/test_build.txt}m, 
                        msg.to_s, 'Difference message is wrong' )
    
    #Check for file with correkt result
    assert(File.exist?("#{FOLDER_FOR_FAILURE}/test_build.txt"), 'Reference file is not created')
    #Check with new file (normally you would copy the file to $expected
    assert_equal_filecontent( "#{FOLDER_FOR_FAILURE}/test_build.txt", DUMMYTEXT, nil )
  end

  #Check, if "Failure" is created in other path
  def test_build_reference_file_default_path()
    self.folder_for_failure = $folder_for_failure #set other failure folder for assertion in this test
    
    #First check. There is a difference, in failure we get the correct result
    msg = assert_raises( Minitest::Assertion ){
      assert_equal_filecontent( "#{$expected}/test_build.txt", DUMMYTEXT )
    }
    assert_match( %r{Result differs to file content #{$expected}/test_build.txt\n\t-> Build <#{$folder_for_failure}/test_build.txt}m, 
                        msg.to_s, 'Difference message is wrong' )
    
    #Check for file with correkt result
    assert(File.exist?("#{$folder_for_failure}/test_build.txt"), 'Reference file is not created')
    #Check with new file (normally you would copy the file to $expected
    assert_equal_filecontent( "#{$folder_for_failure}/test_build.txt", DUMMYTEXT, nil )
  end

  def test_build_reference_file_parameter_error()    
    #First check. There is a difference, in failure we get the correct result
    msg = assert_raises( ArgumentError ){
      assert_equal_filecontent( "<??>.txt", DUMMYTEXT )
    }
  end
  
  def test_build_reference_file_parameter_c()    
    filename = self.class.name
    #First check. There is a difference, in failure we get the correct result
    msg = assert_raises( Minitest::Assertion ){
      assert_equal_filecontent( "#{$expected}/<c>.txt", DUMMYTEXT )
    }
    assert_match( %r{Reference file <#{$expected}/#{filename}.txt> is missing.*-> Build <#{FOLDER_FOR_FAILURE}/#{filename}.txt}m, 
                        msg.to_s )

    #Check for file with correkt result
    assert(File.exist?("#{FOLDER_FOR_FAILURE}/#{filename}.txt" ))
    #Check with new file (normally you would copy the file to $expected
    assert_equal_filecontent( "#{FOLDER_FOR_FAILURE}/#{filename}.txt", DUMMYTEXT, nil )
  end
  
  def test_build_reference_file_parameter_m()
    filename = __method__
    #First check. There is a difference, in failure we get the correct result
    msg = assert_raises( Minitest::Assertion ){
      assert_equal_filecontent( "#{$expected}/<m>.txt", DUMMYTEXT )
    }
    assert_match( %r{Reference file <#{$expected}/#{filename}.txt> is missing.*-> Build <#{FOLDER_FOR_FAILURE}/#{filename}.txt}m, 
                        msg.to_s )


    #Check for file with correkt result
    assert(File.exist?("#{FOLDER_FOR_FAILURE}/#{filename}.txt" ))
    #Check with new file (normally you would copy the file to $expected
    assert_equal_filecontent( "#{FOLDER_FOR_FAILURE}/#{filename}.txt", DUMMYTEXT, nil )
  end
  
end #Test_equal_filecontent 
